# 「どうぶつしょうぎ名人」改造版の使い方

## 完全解析 (最善手の事前計算)

* make コマンドが使える環境を用意する
* Rust, Cargo をインストールしておく
* ターミナルを開いて, このファイル `INSTRACTION.md` があるディレクトリに移動
* ターミナル上で `make RULES=val1n -C precomp 2.txt` を実行
* (もし一瞬で終わって更新されていなそうなら, `make -C precomp clean` を実行してから再度上記)

成功すれば, たとえば次のように表示される.

```
Step 2: result
  black-winning boards:  47347380
  white-winning boards: 196773087
  draw                :   2682700
  max depth : 173
  init depth:  77
Step 2: done!
```

「init depth」の数字が偶数なら先手勝ち, 奇数なら後手勝ち.

* `init depth:  10` → 双方最善に指せば 11 手 (=10+1) で先手の勝ち
* `init depth:  77` → 双方最善に指せば 78 手 (=77+1) で後手の勝ち
* `init depth:   0` → 双方最善に指せば千日手 (無限ループによる引き分け)

後手勝ちの場合は, この解析結果を相手に Web アプリで対局もできる. 対局するには,

* ターミナル上で `make RULES=val1n -C precomp` を実行

これで `precomp/unpruned_ai.txt` が作られる. 続く手順は後述.

## 駒の動きの変え方

先ほどのコマンド内の `RULES=val1n` が駒の動きを指定している. `val1n` は, どうぶつしょうぎの標準ルール.

ルールコードは 5 文字で, 各文字が順にライオン, 象, キリン, ひよこ, にわとりの動きを表す.

* 0 → 十進数 0 = 二進数 00000
* 1 → 十進数 1 = 二進数 00001
* 2 → 十進数 2 = 二進数 00010
* ……
* 9 → 十進数 9 = 二進数 01001
* a → 十進数 10 = 二進数 01010
* b → 十進数 11 = 二進数 01011
* ……
* v → 十進数 31 = 二進数 11111

二進数 5 桁の上位ビットから順に, 後, 斜め後, 横, 斜め前, 前に対応 (1=動ける, 0=動けない)

例:

* にわとりの動き「n」 (十進数 23 = 二進数 10111) → 斜め後以外は動ける
* 象を後にも動けるようにしたければ, 二進数 11010 = 十進数 26 → コードは「q」. よって `RULES=vql1n`

Ruby がインストールされていれば, ルールコードを次のように解読表示できる.

```
$ precomp/src/decode.rb -r val1n
val1n 11111_01010_10101_00001_10111  ← 標準ルール (ラ_象_キ_ひ_に)
$ precomp/src/decode.rb -r vql1n
vql1n 11111_11010_10101_00001_10111  ← 象が後にも動ける
```

## 対局 Web アプリのビルド

* npm, Ruby, ImageMagick, [OptiPNG](https://optipng.sourceforge.net/), [AdvanceCOMP](https://www.advancemame.it/) をインストールしておく
* ターミナルを開いて, このファイル `INSTRACTION.md` があるディレクトリに移動
* ターミナル上で以下のコマンドを実行

```
cd client
ruby images/setup.rb
npm install
npm run build
cd ..
```

あとは `docs/` ディレクトリ以下を Web で公開すればよい. 手元で簡易 Web サーバを起動するなら,

* ターミナルで `ruby -run -e httpd docs -p 8888` を実行 (止めるには `Ctrl-C` キー)
* ブラウザで <http://localhost:8888/> を開く

## 補足

### 解析結果ファイル

`precomp` ディレクトリに作られるファイルたちの内容例と解説.

#### `1.txt` (数億行, 数GB)

```
000a0039c41b002 -1
000a0039041bc02 -1
000a0439001bc02 -1
……
```

初期配置から合法手で到達できるすべての局面を列挙したもの. 「局面」は, 手番側から見た盤面の駒配置と双方の持駒を表す文字列 (後述). 続く数字は,

* 0: 手番側の即負け (相手のトライが成立した状態)
* 1: 手番側が次の一手で勝てる (相手のライオンを取れる状態)
* -1: それ以外

#### `2.txt` (数億行, 数GB)

```
000aa01b400cb09 0
000aa01bb40c009 0
00500210430c009 0
……
```

`1.txt` で列挙された各局面の深さを求めたもの.

* 深さ 0: 手番側の即負け (相手のトライが成立した状態)
* 深さ 1: 手番側が次の一手で勝てる (相手のライオンを取れる状態)
* 深さ 2: あと 2 手で負ける
* 深さ 3: あと 3 手で勝てる
* 深さ 4: あと 4 手で負ける
* ……
* 深さ -1: 双方最善に指せば千日手 (無限ループによる引き分け)

#### `3.txt` (数百万行, 数十MB)

ここからは, 後手必勝という想定のもとで実装されている.

```
 1 58521 4501 279242 0
000a0039041bc02 71 0
 2: 1173313 89 1342 2

0000b029c41a003 71 1
 0: 3 219 2 2919 38 587228

000a0309c41b002 69 2
 3: 1167818 6
 5: 5 109424 48738 4 133271

……
```

後手が必ず最善手を指すことにすれば, 到達できる局面は大幅に絞られる. そのように絞られた局面に補足情報を加えたもの. 容量節約のため, 後手番の局面のみを記録. さらに, 深さ 3 以下の局面は除外 (対局時にその場で探索してもすぐだから).

* 一行目: 「初期局面から初手で移りえる局面」の通し番号一覧
* 二行目: 局面 000a0039041bc02 は深さ 71, 局面通し番号 0 番
* 三行目: 候補手 2 番が最善. 相手の応手しだいで, 次の自番は, 局面通し番号 1173313, 89, 1342, 2 番のどれか.
* ……
* 九・十行目: 局面 000a0309c41b002 では候補手 3 番と 5 番がどちらも最善

#### `unpruned_ai.txt` (数十万行, 数十MB)

```
#RULES val1n
0000b029c41a003 77 0
000a0030c41b902 77 2
000a9030c41b002 77 2
……
```

`3.txt` を簡略化したもの. 「AI」はこれにしたがって指す.

* 一行目: ルールコード `val1n`
* 二行目: 局面 0000b029c41a003 は深さ 77, 候補手 0 番が最善
* ……

もし最善手が複数ある場合も, このファイルには一つだけ記録.

### 局面を表す文字列

Ruby がインストールされていれば, 文字列に対応する局面を次のように表示できる

```
$ precomp/src/decode.rb 41000039a01b002
gl.
.e.
...
ELG
Cc
```

* Lion=ライオン, Elephant=象, Giraffe=きりん, Chick=ひよこ, Hen=にわとり
* 手番側の駒は大文字, 相手は小文字
* 最下行は持駒. たとえば先手がひよこを二枚持っていたら「CC」と表示される.

Unix 系 OS なら, 次のコマンドで逆変換もできる. (`\n` で区切って各行を書く)

```
$ echo 'gl.\n.e.\n...\nELG\ncC' | precomp/src/encode.rb
41000039a01b002
```

確認のため盤面も表示した例:

```
$ echo 'gl.\n.e.\n...\nELG\ncC' | tee /dev/stderr | precomp/src/encode.rb
gl.
.e.
...
ELG
cC
41000039a01b002
```
