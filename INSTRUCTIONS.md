# 「どうぶつしょうぎ名人」改造版の使い方

## 完全解析 (最善手の事前計算)

* make, gzip, cp 等の UNIX 系コマンドが使える環境を用意する
* Rust, Cargo, Ruby をインストールしておく
* ターミナルを開いて, このファイル `INSTRACTION.md` があるディレクトリに移動
* ターミナル上で `make RULES=val1n -C precomp analyze` を実行

成功すれば, たとえば次のように表示される.

```
Step 2: result
  black-winning boards:  47347380
  white-winning boards: 196773087
  draw                :   2682700
  max depth : 173
  init depth:  77
Step 2: done!
```

「init depth」の数字が偶数なら先手勝ち, 奇数なら後手勝ち.

* `init depth:  10` → 双方最善に指せば 11 手 (=10+1) で先手の勝ち
* `init depth:  77` → 双方最善に指せば 78 手 (=77+1) で後手の勝ち
* `init depth:   0` → 双方最善に指せば千日手 (無限ループによる引き分け)

## 駒の動きの変え方

先ほどのコマンド内の `RULES=val1n` が駒の動きを指定している. `val1n` は, どうぶつしょうぎの標準ルール.

ルールコードは 5 文字で, 各文字が順にライオン, 象, キリン, ひよこ, にわとりの動きを表す.

* 文字「0」 → 十進数 0 = 二進数 00000
* 文字「1」 → 十進数 1 = 二進数 00001
* 文字「2」 → 十進数 2 = 二進数 00010
* ……
* 文字「9」 → 十進数 9 = 二進数 01001
* 文字「a」 → 十進数 10 = 二進数 01010
* 文字「b」 → 十進数 11 = 二進数 01011
* ……
* 文字「v」 → 十進数 31 = 二進数 11111

二進数 5 桁の上位ビットから順に, 後, 斜め後, 横, 斜め前, 前に対応 (1=動ける, 0=動けない)

例:

* にわとりの動き「n」 (十進数 23 = 二進数 10111) → 斜め後以外は動ける
* 象を後にも動けるようにしたければ, 二進数 11010 = 十進数 26 → 文字は「q」. よって `RULES=vql1n`

Ruby がインストールされていれば, ルールコードを次のように解読表示できる.

```
$ precomp/src/decode.rb -r val1n
val1n 11111_01010_10101_00001_10111  ← 標準ルール (ラ_象_キ_ひ_に)
$ precomp/src/decode.rb -r vql1n
vql1n 11111_11010_10101_00001_10111  ← 象が後にも動ける
```

なお, ルールごとに数 GB の解析結果ファイルが `precomp/` ディレクトリに保存される (詳細は後述). それらを消すには, ターミナル上で `make -C precomp clean` を実行.

## 対局 Web アプリのビルド

最初の一回だけ:

* npm, Ruby, ImageMagick をインストールしておく
* ターミナルを開いて, このファイル `INSTRACTION.md` があるディレクトリに移動
* ターミナル上で以下のコマンドを実行

```
cd client
npm install
cd ..
```

ルールなど何か変更したら毎回:

* ターミナル上で `make -C precomp RULES=val1n` を実行

容量を節約したけば下記でもよい. (アプリの容量が, たとえば 160MB から 5MB に減る. ただし, 完全解析の結果が後手勝ちでなければならず, また後手は決まった手しか指さない.)

* ターミナル上で `make -C precomp RULES=val1n smalldocs` を実行

あとは `docs/` ディレクトリ以下を Web で公開すれば対局できる. 手元で簡易 Web サーバを起動するなら,

* ターミナルで `ruby -run -e httpd docs -p 8888` を実行 (止めるには `Ctrl-C` キー)
* ブラウザで <http://localhost:8888/> を開く

解析結果ファイルは `precomp/` ディレクトリに生成され, その中から Web アプリに必要なファイルが `docs/` にコピーされる. 作業後は, 不要なら前者は消してもよい.

* ターミナルで `make clean` →  `precomp/` ディレクトリの中間生成ファイルを消す
* `make distclean` → `precomp/` ディレクトリの解析結果ファイルをすべて消す (中間物も最終結果も)

## 補足

### 解析結果ファイル

`precomp` ディレクトリに作られるファイルたちの内容例と解説. ファイル名は実際にはプレフィクスがつく. たとえばルールコード `val1n` の `1.txt` なら `r_val1n_1.txt`.

#### `1.txt` (数億行, 数GB)

```
000a0039c41b002 -1
000a0039041bc02 -1
000a0439001bc02 -1
……
```

初期配置から合法手で到達できるすべての局面を列挙したもの. 「局面」は, 手番側から見た盤面の駒配置と双方の持駒を表す文字列 (後述). 続く数字は,

* 0: 手番側の即負け (相手のトライが成立した状態)
* 1: 手番側が次の一手で勝てる (相手のライオンを取れる状態)
* -1: それ以外

#### `2.txt` (数億行, 数GB)

```
000aa01b400cb09 0
000aa01bb40c009 0
00500210430c009 0
……
```

`1.txt` で列挙された各局面の深さを求めたもの.

* 深さ 0: 手番側の即負け (相手のトライが成立した状態)
* 深さ 1: 手番側が次の一手で勝てる (相手のライオンを取れる状態)
* 深さ 2: あと 2 手で負ける
* 深さ 3: あと 3 手で勝てる
* 深さ 4: あと 4 手で負ける
* ……
* 深さ -1: 双方最善に指せば千日手 (無限ループによる引き分け)

#### `2_cooked.txt` (`2.txt` の数分の一)

`2.txt` のうち深さ 4 以上の行だけを抽出してソートしたもの.

* 二分探索できるようにソートしておく
* ファイル容量を節約するため, 深さ 3 以下は省略 (→ 実行時にその場で調べなおす)

#### `keys.gz`, `vals.gz` (百数十 MB, 数十 MB)

`2_cooked.txt` の局面文字列のみを抽出したのが `keys.gz`, 深さのみを抽出したのが `vals.gz`. 容量節約のため, どちらもバイナリファイルに詰めてさらに GZIP 圧縮している. 「AI」はこれを参照して指す.

* `keys.gz`: 局面文字列 (16 進数 15 桁) を 64bit 符号なし整数 (リトルエンディアン) としてパック
* `vals.gz`: 8bit 符号なし整数としてパック

#### `3.txt` (数百万行, 数十MB)

※ ここからは, 後手必勝という前提でさらにファイルサイズを絞った版. `make ... smalldocs` の場合は, `keys.gz`, `vals.gz` のかわりに以下が使われる.

```
 1 58521 4501 279242 0
000a0039041bc02 71 0
 2: 1173313 89 1342 2

0000b029c41a003 71 1
 0: 3 219 2 2919 38 587228

000a0309c41b002 69 2
 3: 1167818 6
 5: 5 109424 48738 4 133271

……
```

後手が必ず最善手を指すことにすれば, 到達できる局面は大幅に絞られる. そのように絞られた局面に補足情報を加えたもの. 容量節約のため, 後手番の局面のみを記録. さらに, 深さ 3 以下の局面は除外 (対局時にその場で探索してもすぐだから).

* 一行目: 「初期局面から初手で移りえる局面」の通し番号一覧
* 二行目: 局面 000a0039041bc02 は深さ 71, 局面通し番号 0 番
* 三行目: 候補手 2 番が最善. 相手の応手しだいで, 次の自番は, 局面通し番号 1173313, 89, 1342, 2 番のどれか.
* ……
* 九・十行目: 局面 000a0309c41b002 では候補手 3 番と 5 番がどちらも最善

#### `unpruned_ai.txt` (数十万行, 数十MB)

```
0000b029c41a003 77 0
000a0030c41b902 77 2
000a9030c41b002 77 2
……
```

`3.txt` を簡略化したもの. 「AI」はこれにしたがって指す.

* 一行目: 局面 0000b029c41a003 は深さ 77, 候補手 0 番が最善
* ……

もし最善手が複数ある場合も, このファイルには一つだけ記録.

### 局面を表す文字列

#### ツール

Ruby がインストールされていれば, 文字列に対応する局面を次のように表示できる

```
$ ./precomp/src/decode.rb 51000a09001b002
gl.
...
..e
EL.
Cgc
```

* Lion=ライオン, Elephant=象, Giraffe=きりん, Chick=ひよこ, Hen=にわとり
* 手番側の駒は大文字, 相手は小文字
* 最下行は持駒. たとえば先手がひよこを二枚持っていたら「CC」と表示される.

Unix 系 OS なら, 次のコマンドで逆変換もできる. (`\n` で区切って各行を書く)

```
$ echo 'gl.\n...\n..e\nEL.\nCgc' | ./precomp/src/encode.rb
51000a09001b002
```

確認のため盤面も表示した例:

```
$ echo 'gl.\n...\n..e\nEL.\nCgc' | tee /dev/stderr | ./precomp/src/encode.rb
gl.
...
..e
EL.
Cgc
51000a09001b002
```

#### 読み方

局面文字列は, 15 桁の十六進数 (60bit).

例: 51000a09001b002

* 先頭 3 文字「510」 … 持駒 (12bit)
  * 十六進数 510 = 二進数 01 01 00 01 00 00
  * 上位から順に 2bit ずつで, 順に相手側のひよこ, きりん, 象, 手番側のひよこ, きりん, 象の持駒数
  * この例なら, 相手側はひよこときりんを 1 枚ずつ, 手番側はひよこを 1 枚持っている
* 残り 12 文字「00a09001b002」 … 盤面 (48bit)
  * 00a0 → 盤面右列は上から順に, 空・空・相手象・空
  * 9001 → 盤面中列は上から順に, 相手ライオン・空・空・手番ライオン
  * b002 → 盤面左列は上から順に, 相手きりん・空・空・手番象
  * 文字は
    * 0 空
    * 1 手番ライオン
    * 2 手番象
    * 3 手番きりん
    * 4 手番ひよこ
    * 5 手番にわとり
    * 9 相手ライオン
    * a 相手象
    * b 相手きりん
    * c 相手ひよこ
    * d 手番にわとり

盤面は常に手番側を手前として表す. 解析結果ファイルでは, 元の盤面と左右反転した盤面とでそれぞれ上記の文字列を生成し, 16 進数として小さい方を採用する (ルールの左右対称性を利用したサイズ削減).
